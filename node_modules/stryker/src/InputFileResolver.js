"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fileUtils_1 = require("./utils/fileUtils");
var _ = require("lodash");
var log4js = require("log4js");
var path = require("path");
var log = log4js.getLogger('InputFileResolver');
var DEFAULT_INPUT_FILE_PROPERTIES = { mutated: false, included: true };
var InputFileResolver = /** @class */ (function () {
    function InputFileResolver(mutate, allFileExpressions) {
        this.validateFileDescriptor(allFileExpressions);
        this.validateMutationArray(mutate);
        this.mutateResolver = PatternResolver.parse(mutate || []);
        this.inputFileResolver = PatternResolver.parse(allFileExpressions);
    }
    InputFileResolver.prototype.resolve = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var results, inputFiles, mutateFiles;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.all([this.inputFileResolver.resolve(), this.mutateResolver.resolve()])];
                    case 1:
                        results = _a.sent();
                        inputFiles = results[0];
                        mutateFiles = results[1];
                        this.markAdditionalFilesToMutate(inputFiles, mutateFiles.map(function (m) { return m.path; }));
                        this.logFilesToMutate(inputFiles);
                        return [2 /*return*/, inputFiles];
                }
            });
        });
    };
    InputFileResolver.prototype.validateFileDescriptor = function (maybeInputFileDescriptors) {
        maybeInputFileDescriptors.forEach(function (maybeInputFileDescriptor) {
            if (_.isObject(maybeInputFileDescriptor)) {
                if (Object.keys(maybeInputFileDescriptor).indexOf('pattern') === -1) {
                    throw Error("File descriptor " + JSON.stringify(maybeInputFileDescriptor) + " is missing mandatory property 'pattern'.");
                }
                else {
                    maybeInputFileDescriptor = maybeInputFileDescriptor;
                    if (fileUtils_1.isOnlineFile(maybeInputFileDescriptor.pattern) && maybeInputFileDescriptor.mutated) {
                        throw new Error("Cannot mutate web url \"" + maybeInputFileDescriptor.pattern + "\".");
                    }
                }
            }
        });
    };
    InputFileResolver.prototype.validateMutationArray = function (mutationArray) {
        if (mutationArray) {
            mutationArray.forEach(function (mutation) {
                if (fileUtils_1.isOnlineFile(mutation)) {
                    throw new Error("Cannot mutate web url \"" + mutation + "\".");
                }
            });
        }
    };
    InputFileResolver.prototype.markAdditionalFilesToMutate = function (allInputFiles, additionalMutateFiles) {
        var errors = [];
        additionalMutateFiles.forEach(function (mutateFile) {
            if (!allInputFiles.filter(function (inputFile) { return inputFile.path === mutateFile; }).length) {
                errors.push("Could not find mutate file \"" + mutateFile + "\" in list of files.");
            }
        });
        if (errors.length > 0) {
            throw new Error(errors.join(' '));
        }
        allInputFiles.forEach(function (file) { return file.mutated = additionalMutateFiles.some(function (mutateFile) { return mutateFile === file.path; }) || file.mutated; });
    };
    InputFileResolver.prototype.logFilesToMutate = function (allInputFiles) {
        var mutateFiles = allInputFiles.filter(function (file) { return file.mutated; });
        if (mutateFiles.length) {
            log.info("Found " + mutateFiles.length + " of " + allInputFiles.length + " file(s) to be mutated.");
        }
        else {
            log.warn("No files marked to be mutated, stryker will perform a dry-run without actually mutating anything.");
        }
        if (log.isDebugEnabled) {
            log.debug('All input files in order:%s', allInputFiles.map(function (file) { return '\n\t' + JSON.stringify(file); }));
        }
    };
    return InputFileResolver;
}());
exports.default = InputFileResolver;
var PatternResolver = /** @class */ (function () {
    function PatternResolver(descriptor, previous) {
        this.previous = previous;
        this.ignore = false;
        if (typeof descriptor === 'string') {
            this.descriptor = _.assign({ pattern: descriptor }, DEFAULT_INPUT_FILE_PROPERTIES);
            this.ignore = descriptor.indexOf('!') === 0;
            if (this.ignore) {
                this.descriptor.pattern = descriptor.substring(1);
            }
        }
        else {
            this.descriptor = descriptor;
        }
    }
    PatternResolver.prototype.resolve = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var globbingTask, results, previousFiles_1, currentFiles_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.ignore && !this.previous)) return [3 /*break*/, 1];
                        return [2 /*return*/, Promise.resolve([])];
                    case 1:
                        globbingTask = this.resolveGlobbingExpression(this.descriptor.pattern)
                            .then(function (filePaths) { return filePaths.map(function (filePath) { return _this.createInputFile(filePath); }); });
                        if (!this.previous) return [3 /*break*/, 3];
                        return [4 /*yield*/, Promise.all([this.previous.resolve(), globbingTask])];
                    case 2:
                        results = _a.sent();
                        previousFiles_1 = results[0];
                        currentFiles_1 = results[1];
                        // If this expression started with a '!', exclude current files
                        if (this.ignore) {
                            return [2 /*return*/, previousFiles_1.filter(function (previousFile) { return currentFiles_1.every(function (currentFile) { return previousFile.path !== currentFile.path; }); })];
                        }
                        else {
                            // Only add files which were not already added
                            return [2 /*return*/, previousFiles_1.concat(currentFiles_1.filter(function (currentFile) { return !previousFiles_1.some(function (file) { return file.path === currentFile.path; }); }))];
                        }
                        return [3 /*break*/, 4];
                    case 3: return [2 /*return*/, globbingTask];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    PatternResolver.empty = function () {
        var emptyResolver = new PatternResolver('');
        emptyResolver.ignore = true;
        return emptyResolver;
    };
    PatternResolver.parse = function (inputFileExpressions) {
        var expressions = inputFileExpressions.map(function (i) { return i; }); // work on a copy as we're changing the array state
        var current = PatternResolver.empty();
        var expression = expressions.shift();
        while (expression) {
            current = new PatternResolver(expression, current);
            expression = expressions.shift();
        }
        return current;
    };
    PatternResolver.prototype.resolveGlobbingExpression = function (pattern) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var files;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!fileUtils_1.isOnlineFile(pattern)) return [3 /*break*/, 1];
                        return [2 /*return*/, Promise.resolve([pattern])];
                    case 1: return [4 /*yield*/, fileUtils_1.glob(pattern)];
                    case 2:
                        files = _a.sent();
                        if (files.length === 0) {
                            this.reportEmptyGlobbingExpression(pattern);
                        }
                        return [2 /*return*/, files.map(function (f) { return path.resolve(path.normalize(f)); })];
                }
            });
        });
    };
    PatternResolver.prototype.reportEmptyGlobbingExpression = function (expression) {
        log.warn("Globbing expression \"" + expression + "\" did not result in any files.");
    };
    PatternResolver.prototype.createInputFile = function (path) {
        var inputFile = _.assign({ path: path }, DEFAULT_INPUT_FILE_PROPERTIES, this.descriptor);
        delete inputFile['pattern'];
        return inputFile;
    };
    return PatternResolver;
}());
//# sourceMappingURL=InputFileResolver.js.map