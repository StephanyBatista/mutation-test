'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var MutatorOrchestrator_1 = require("./MutatorOrchestrator");
var config_1 = require("stryker-api/config");
var SandboxCoordinator_1 = require("./SandboxCoordinator");
var ReporterOrchestrator_1 = require("./ReporterOrchestrator");
var test_runner_1 = require("stryker-api/test_runner");
var TestFrameworkOrchestrator_1 = require("./TestFrameworkOrchestrator");
var MutantTestMatcher_1 = require("./MutantTestMatcher");
var InputFileResolver_1 = require("./InputFileResolver");
var ConfigReader_1 = require("./ConfigReader");
var PluginLoader_1 = require("./PluginLoader");
var ScoreResultCalculator_1 = require("./ScoreResultCalculator");
var ConfigValidator_1 = require("./ConfigValidator");
var CoverageInstrumenter_1 = require("./coverage/CoverageInstrumenter");
var objectUtils_1 = require("./utils/objectUtils");
var TempFolder_1 = require("./utils/TempFolder");
var log4js = require("log4js");
var Timer_1 = require("./utils/Timer");
var log = log4js.getLogger('Stryker');
var humanReadableTestState = function (testState) {
    switch (testState) {
        case test_runner_1.TestStatus.Success:
            return 'SUCCESS';
        case test_runner_1.TestStatus.Failed:
            return 'FAILED';
        case test_runner_1.TestStatus.Skipped:
            return 'SKIPPED';
    }
};
var Stryker = /** @class */ (function () {
    /**
     * The Stryker mutation tester.
     * @constructor
     * @param {Object} [options] - Optional options.
     */
    function Stryker(options) {
        this.timer = new Timer_1.default();
        var configReader = new ConfigReader_1.default(options);
        this.config = configReader.readConfig();
        this.setGlobalLogLevel(); // logLevel could be changed
        this.loadPlugins();
        this.applyConfigEditors();
        this.setGlobalLogLevel(); // logLevel could be changed
        this.freezeConfig();
        this.reporter = new ReporterOrchestrator_1.default(this.config).createBroadcastReporter();
        this.testFramework = new TestFrameworkOrchestrator_1.default(this.config).determineTestFramework();
        this.coverageInstrumenter = new CoverageInstrumenter_1.default(this.config.coverageAnalysis, this.testFramework);
        new ConfigValidator_1.default(this.config, this.testFramework).validate();
    }
    /**
     * Runs mutation testing. This may take a while.
     * @function
     */
    Stryker.prototype.runMutationTest = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var inputFiles, _a, runResult, sandboxCoordinator, mutantResults, score;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.timer.reset();
                        return [4 /*yield*/, new InputFileResolver_1.default(this.config.mutate, this.config.files).resolve()];
                    case 1:
                        inputFiles = _b.sent();
                        TempFolder_1.TempFolder.instance().initialize();
                        return [4 /*yield*/, this.initialTestRun(inputFiles)];
                    case 2:
                        _a = _b.sent(), runResult = _a.runResult, sandboxCoordinator = _a.sandboxCoordinator;
                        if (!(runResult.tests.length === 0)) return [3 /*break*/, 3];
                        log.warn('No tests were executed. Stryker will exit prematurely. Please check your configuration.');
                        return [2 /*return*/, []];
                    case 3:
                        if (!(runResult && inputFiles && sandboxCoordinator)) return [3 /*break*/, 8];
                        return [4 /*yield*/, this.generateAndRunMutations(inputFiles, runResult, sandboxCoordinator)];
                    case 4:
                        mutantResults = _b.sent();
                        score = ScoreResultCalculator_1.default.calculate(mutantResults);
                        this.reporter.onScoreCalculated(score);
                        ScoreResultCalculator_1.default.determineExitCode(score, this.config.thresholds);
                        return [4 /*yield*/, this.wrapUpReporter()];
                    case 5:
                        _b.sent();
                        return [4 /*yield*/, TempFolder_1.TempFolder.instance().clean()];
                    case 6:
                        _b.sent();
                        return [4 /*yield*/, this.logDone()];
                    case 7:
                        _b.sent();
                        return [2 /*return*/, mutantResults];
                    case 8: throw new Error('Resulting object did not contain runResult, inputFiles or sandboxCoordinator');
                }
            });
        });
    };
    Stryker.prototype.filterOutFailedTests = function (runResult) {
        return runResult.tests.filter(function (testResult) { return testResult.status === test_runner_1.TestStatus.Failed; });
    };
    Stryker.prototype.loadPlugins = function () {
        if (this.config.plugins) {
            new PluginLoader_1.default(this.config.plugins).load();
        }
    };
    Stryker.prototype.initialTestRun = function (inputFiles) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var sandboxCoordinator, runResult, failedTests;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sandboxCoordinator = new SandboxCoordinator_1.default(this.config, inputFiles, this.testFramework, this.reporter);
                        return [4 /*yield*/, sandboxCoordinator.initialRun(this.coverageInstrumenter)];
                    case 1:
                        runResult = _a.sent();
                        switch (runResult.status) {
                            case test_runner_1.RunStatus.Complete:
                                failedTests = this.filterOutFailedTests(runResult);
                                if (failedTests.length) {
                                    this.logFailedTestsInInitialRun(failedTests);
                                    throw new Error('There were failed tests in the initial test run:');
                                }
                                else {
                                    this.logInitialTestRunSucceeded(runResult.tests);
                                    return [2 /*return*/, { runResult: runResult, sandboxCoordinator: sandboxCoordinator }];
                                }
                            case test_runner_1.RunStatus.Error:
                                this.logErrorsInInitialRun(runResult);
                                break;
                            case test_runner_1.RunStatus.Timeout:
                                this.logTimeoutInitialRun(runResult);
                                break;
                        }
                        throw new Error('Something went wrong in the initial test run');
                }
            });
        });
    };
    Stryker.prototype.generateAndRunMutations = function (inputFiles, initialRunResult, sandboxCoordinator) {
        var mutants = this.generateMutants(inputFiles, initialRunResult);
        if (mutants.length) {
            return sandboxCoordinator.runMutants(mutants);
        }
        else {
            log.info('It\'s a mutant-free world, nothing to test.');
            return Promise.resolve([]);
        }
    };
    Stryker.prototype.generateMutants = function (inputFiles, runResult) {
        var mutatorOrchestrator = new MutatorOrchestrator_1.default(this.reporter);
        var mutants = mutatorOrchestrator.generateMutants(inputFiles
            .filter(function (inputFile) { return inputFile.mutated; })
            .map(function (file) { return file.path; }));
        log.info(mutants.length + " Mutant(s) generated");
        var mutantRunResultMatcher = new MutantTestMatcher_1.default(mutants, runResult, this.coverageInstrumenter.retrieveStatementMapsPerFile(), this.config, this.reporter);
        mutantRunResultMatcher.matchWithMutants();
        return mutants;
    };
    Stryker.prototype.wrapUpReporter = function () {
        var maybePromise = this.reporter.wrapUp();
        if (objectUtils_1.isPromise(maybePromise)) {
            return maybePromise;
        }
        else {
            return Promise.resolve();
        }
    };
    Stryker.prototype.applyConfigEditors = function () {
        var _this = this;
        config_1.ConfigEditorFactory.instance().knownNames().forEach(function (configEditorName) {
            config_1.ConfigEditorFactory.instance().create(configEditorName, undefined).edit(_this.config);
        });
    };
    Stryker.prototype.freezeConfig = function () {
        objectUtils_1.freezeRecursively(this.config);
        if (log.isDebugEnabled()) {
            log.debug("Using config: " + JSON.stringify(this.config));
        }
    };
    Stryker.prototype.logInitialTestRunSucceeded = function (tests) {
        log.info('Initial test run succeeded. Ran %s tests in %s.', tests.length, this.timer.humanReadableElapsed());
    };
    Stryker.prototype.logDone = function () {
        log.info('Done in %s.', this.timer.humanReadableElapsed());
    };
    Stryker.prototype.setGlobalLogLevel = function () {
        log4js.setGlobalLogLevel(this.config.logLevel);
    };
    Stryker.prototype.logFailedTestsInInitialRun = function (failedTests) {
        var message = 'One or more tests failed in the initial test run:';
        failedTests.forEach(function (test) {
            message += "\n\t" + test.name;
            if (test.failureMessages && test.failureMessages.length) {
                message += "\n\t" + test.failureMessages.join('\n\t');
            }
        });
        log.error(message);
    };
    Stryker.prototype.logErrorsInInitialRun = function (runResult) {
        var message = 'One or more tests resulted in an error in the initial test run:';
        if (runResult.errorMessages && runResult.errorMessages.length) {
            runResult.errorMessages.forEach(function (error) { return message += "\n\t" + error; });
        }
        log.error(message);
    };
    Stryker.prototype.logTimeoutInitialRun = function (runResult) {
        var message = 'Initial test run timed out! Ran following tests before timeout:';
        runResult.tests.forEach(function (test) { return "\n\t" + test.name + " " + humanReadableTestState(test.status); });
        log.error(message);
    };
    return Stryker;
}());
exports.default = Stryker;
//# sourceMappingURL=Stryker.js.map