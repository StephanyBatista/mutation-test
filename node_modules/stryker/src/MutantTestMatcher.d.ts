import Mutant from './Mutant';
import StrictReporter from './reporters/StrictReporter';
import { StatementMapDictionary } from './coverage/CoverageInstrumenter';
import { RunResult } from 'stryker-api/test_runner';
import { StrykerOptions } from 'stryker-api/core';
export default class MutantTestMatcher {
    private mutants;
    private initialRunResult;
    private statementMaps;
    private options;
    private reporter;
    constructor(mutants: Mutant[], initialRunResult: RunResult, statementMaps: StatementMapDictionary, options: StrykerOptions, reporter: StrictReporter);
    private readonly baseline;
    matchWithMutants(): void;
    private isCoveredByBaseline(filename, statementId);
    private isCoveredByTest(testId, filename, statementId);
    /**
     * Map the Mutant object on the MatchMutant Object.
     * @param mutant The mutant.
     * @returns The MatchedMutant
     */
    private mapMutantOnMatchedMutant(mutant);
    /**
     * Finds the smallest statement that covers a mutant.
     * @param mutant The mutant.
     * @param statementMap of the covering file.
     * @returns The index of the coveredFile which contains the smallest statement surrounding the mutant.
     */
    private findSmallestCoveringStatement(mutant, statementMap);
    /**
     * Indicates whether a statement is the smallest statement of the two statements provided.
     * @param originalLocation The area which may cover a bigger area than the newLocation.
     * @param newLocation The area which may cover a smaller area than the originalLocation.
     * @returns true if the newLocation covers a smaller area than the originalLocation, making it the smaller statement.
     */
    private isNewSmallestStatement(originalLocation, newLocation);
    /**
     * Indicates whether a statement covers a mutant.
     * @param mutantLocation The location of the mutant.
     * @param statementLocation The location of the statement.
     * @returns true if the statment covers the mutant.
     */
    private statementCoversMutant(mutantLocation, statementLocation);
    private findCoverageCollectionForTest(testId);
    private isCoveragePerTestResult(coverage);
}
