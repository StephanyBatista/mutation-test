"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chalk = require("chalk");
var log4js = require("log4js");
var report_1 = require("stryker-api/report");
var ClearTextScoreTable_1 = require("./ClearTextScoreTable");
var os = require("os");
var log = log4js.getLogger('ClearTextReporter');
var ClearTextReporter = /** @class */ (function () {
    function ClearTextReporter(options) {
        this.options = options;
        this.out = process.stdout;
    }
    ClearTextReporter.prototype.writeLine = function (output) {
        this.out.write("" + (output || '') + os.EOL);
    };
    ClearTextReporter.prototype.onAllMutantsTested = function (mutantResults) {
        var _this = this;
        this.writeLine();
        var totalTests = 0;
        // use these fn's in order to preserve the 'this` pointer
        var logDebugFn = function (input) { return log.debug(input); };
        var writeLineFn = function (input) { return _this.writeLine(input); };
        mutantResults.forEach(function (result) {
            if (result.testsRan) {
                totalTests += result.testsRan.length;
            }
            switch (result.status) {
                case report_1.MutantStatus.Killed:
                    log.debug(chalk.bold.green('Mutant killed!'));
                    _this.logMutantResult(result, logDebugFn);
                    break;
                case report_1.MutantStatus.TimedOut:
                    log.debug(chalk.bold.yellow('Mutant timed out!'));
                    _this.logMutantResult(result, logDebugFn);
                    break;
                case report_1.MutantStatus.Error:
                    log.debug(chalk.bold.yellow('Mutant caused an error!'));
                    _this.logMutantResult(result, logDebugFn);
                    break;
                case report_1.MutantStatus.Survived:
                    _this.writeLine(chalk.bold.red('Mutant survived!'));
                    _this.logMutantResult(result, writeLineFn);
                    break;
                case report_1.MutantStatus.NoCoverage:
                    _this.writeLine(chalk.bold.yellow('Mutant survived! (no coverage)'));
                    _this.logMutantResult(result, writeLineFn);
                    break;
            }
        });
        this.writeLine("Ran " + (totalTests / mutantResults.length).toFixed(2) + " tests per mutant on average.");
    };
    ClearTextReporter.prototype.logMutantResult = function (result, logImplementation) {
        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);
        logImplementation('Mutator: ' + result.mutatorName);
        result.originalLines.split('\n').forEach(function (line) {
            logImplementation(chalk.red('-   ' + line));
        });
        result.mutatedLines.split('\n').forEach(function (line) {
            logImplementation(chalk.green('+   ' + line));
        });
        logImplementation('');
        if (this.options.coverageAnalysis === 'perTest') {
            this.logExecutedTests(result, logImplementation);
        }
        else if (result.testsRan && result.testsRan.length > 0) {
            logImplementation('Ran all tests for this mutant.');
        }
    };
    ClearTextReporter.prototype.logExecutedTests = function (result, logImplementation) {
        var clearTextReporterConfig = this.options['clearTextReporter'];
        if (result.testsRan && result.testsRan.length > 0) {
            var testsToLog = 3;
            if (clearTextReporterConfig && typeof clearTextReporterConfig.maxTestsToLog === 'number') {
                testsToLog = clearTextReporterConfig.maxTestsToLog;
            }
            if (testsToLog > 0) {
                logImplementation('Tests ran: ');
                for (var i = 0; i < testsToLog; i++) {
                    if (i > result.testsRan.length - 1) {
                        break;
                    }
                    logImplementation('    ' + result.testsRan[i]);
                }
                if (testsToLog < result.testsRan.length) {
                    logImplementation("  and " + (result.testsRan.length - testsToLog) + " more tests!");
                }
                logImplementation('');
            }
        }
    };
    ClearTextReporter.prototype.onScoreCalculated = function (score) {
        this.writeLine(new ClearTextScoreTable_1.default(score, this.options.thresholds).draw());
    };
    return ClearTextReporter;
}());
exports.default = ClearTextReporter;
//# sourceMappingURL=ClearTextReporter.js.map