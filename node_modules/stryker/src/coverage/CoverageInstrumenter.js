"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log4js = require("log4js");
var stream_1 = require("stream");
var objectUtils_1 = require("../utils/objectUtils");
var CoverageInstrumenterStream_1 = require("./CoverageInstrumenterStream");
var log = log4js.getLogger('CoverageInstrumenter');
var COVERAGE_CURRENT_TEST_VARIABLE_NAME = '__strykerCoverageCurrentTest__';
/**
 * Represents the CoverageInstrumenter
 * Responsible for managing the instrumentation of all files to be mutated.
 * In case of `perTest` coverageAnalysis it will hookin to the test framework to accomplish that.
 */
var CoverageInstrumenter = /** @class */ (function () {
    function CoverageInstrumenter(coverageAnalysis, testFramework) {
        this.coverageAnalysis = coverageAnalysis;
        this.testFramework = testFramework;
        this.coverageInstrumenterStreamPerFile = Object.create(null);
    }
    CoverageInstrumenter.prototype.instrumenterStreamForFile = function (file) {
        if (file.mutated) {
            /*
            Coverage variable *must* have the name '__coverage__'. Only that variable
            is reported back to the TestRunner process when using one of the karma
            test framework adapters (karma-jasmine, karma-mocha, ...).
      
            However, when coverageAnalysis is 'perTest' we don't choose that variable name right away,
            because we need that variable to hold all coverage results per test. Instead, we use __strykerCoverageCurrentTest__
            and after each test copy over the value of that current test to the global coverage object __coverage__
             */
            switch (this.coverageAnalysis) {
                case 'all':
                    return this.createStreamForFile('__coverage__', file.path);
                case 'perTest':
                    return this.createStreamForFile(COVERAGE_CURRENT_TEST_VARIABLE_NAME, file.path);
            }
        }
        // By default, do not instrument for code coverage
        return new stream_1.PassThrough();
    };
    CoverageInstrumenter.prototype.hooksForTestRun = function () {
        if (this.testFramework && this.coverageAnalysis === 'perTest') {
            log.debug("Adding test hooks file for coverageAnalysis \"perTest\"");
            return objectUtils_1.wrapInClosure("\n          var id = 0;\n          window.__coverage__ = globalCoverage = { deviations: {} };\n          " + this.testFramework.beforeEach(beforeEachFragmentPerTest) + "\n          " + this.testFramework.afterEach(afterEachFragmentPerTest) + "\n          " + cloneFunctionFragment + ";\n      ");
        }
        else {
            return '';
        }
    };
    CoverageInstrumenter.prototype.retrieveStatementMapsPerFile = function () {
        var _this = this;
        var statementMapsPerFile = Object.create(null);
        Object.keys(this.coverageInstrumenterStreamPerFile)
            .forEach(function (key) { return statementMapsPerFile[key] = _this.coverageInstrumenterStreamPerFile[key].statementMap; });
        return statementMapsPerFile;
    };
    CoverageInstrumenter.prototype.createStreamForFile = function (coverageVariable, fileName) {
        var stream = new CoverageInstrumenterStream_1.default(coverageVariable, fileName);
        this.coverageInstrumenterStreamPerFile[fileName] = stream;
        return stream;
    };
    return CoverageInstrumenter;
}());
exports.default = CoverageInstrumenter;
var cloneFunctionFragment = "    \n    function clone(source) {\n        var result = source;\n        if (Array.isArray(source)) {\n            result = [];\n            source.forEach(function (child, index) {\n                result[index] = clone(child);\n            });\n        } else if (typeof source == \"object\") {\n            result = {};\n            for (var i in source) {\n                result[i] = clone(source[i]);\n            }\n        }\n        return result;\n    }";
var beforeEachFragmentPerTest = "\nif (!globalCoverage.baseline && window." + COVERAGE_CURRENT_TEST_VARIABLE_NAME + ") {\n  globalCoverage.baseline = clone(window." + COVERAGE_CURRENT_TEST_VARIABLE_NAME + ");\n}";
var afterEachFragmentPerTest = "\n  globalCoverage.deviations[id] = coverageResult = {};\n  id++;\n  var coveragePerFile = window." + COVERAGE_CURRENT_TEST_VARIABLE_NAME + ";\n  if(coveragePerFile) {\n    Object.keys(coveragePerFile).forEach(function (file) {\n        var coverage = coveragePerFile[file];\n        var baseline = globalCoverage.baseline[file];\n        var fileResult = { s: {} };\n        var touchedFile = false;\n        for(var i in coverage.s){\n          if(coverage.s[i] !== baseline.s[i]){\n            fileResult.s[i] = coverage.s[i];\n            touchedFile = true;\n          }\n        }\n        if(touchedFile){\n          coverageResult[file] = fileResult;\n        }\n    });\n  }";
//# sourceMappingURL=CoverageInstrumenter.js.map