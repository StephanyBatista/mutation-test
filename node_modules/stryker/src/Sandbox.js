"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var path = require("path");
var log4js = require("log4js");
var _ = require("lodash");
var mkdirp = require("mkdirp");
var objectUtils_1 = require("./utils/objectUtils");
var fileUtils_1 = require("./utils/fileUtils");
var ResilientTestRunnerFactory_1 = require("./isolated-runner/ResilientTestRunnerFactory");
var TempFolder_1 = require("./utils/TempFolder");
var log = log4js.getLogger('Sandbox');
var Sandbox = /** @class */ (function () {
    function Sandbox(options, index, files, testFramework, coverageInstrumenter) {
        this.options = options;
        this.index = index;
        this.files = files;
        this.testFramework = testFramework;
        this.coverageInstrumenter = coverageInstrumenter;
        this.workingFolder = TempFolder_1.TempFolder.instance().createRandomFolder('sandbox');
        log.debug('Creating a sandbox for files in %s', this.workingFolder);
        this.testHooksFile = path.join(this.workingFolder, '___testHooksForStryker.js');
    }
    Sandbox.prototype.initialize = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fillSandbox()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.initializeTestRunner()];
                }
            });
        });
    };
    Sandbox.prototype.run = function (timeout) {
        return this.testRunner.run({ timeout: timeout });
    };
    Sandbox.prototype.dispose = function () {
        return this.testRunner.dispose() || Promise.resolve();
    };
    Sandbox.prototype.runMutant = function (mutant) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var targetedFile, runResult;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        targetedFile = this.fileMap[mutant.filename];
                        return [4 /*yield*/, Promise.all([mutant.save(targetedFile), this.filterTests(mutant)])];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.run(this.calculateTimeout(mutant))];
                    case 2:
                        runResult = _a.sent();
                        return [4 /*yield*/, mutant.reset(targetedFile)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, runResult];
                }
            });
        });
    };
    Sandbox.prototype.fillSandbox = function () {
        var _this = this;
        this.fileMap = Object.create(null);
        var copyPromises = this.files
            .map(function (file) { return _this.copyFile(file); });
        if (this.coverageInstrumenter) {
            copyPromises.push(TempFolder_1.TempFolder.instance().writeFile(this.testHooksFile, this.coverageInstrumenter.hooksForTestRun()));
        }
        else {
            copyPromises.push(TempFolder_1.TempFolder.instance().writeFile(this.testHooksFile, ''));
        }
        return Promise.all(copyPromises);
    };
    Sandbox.prototype.copyFile = function (file) {
        if (fileUtils_1.isOnlineFile(file.path)) {
            this.fileMap[file.path] = file.path;
            return Promise.resolve();
        }
        else {
            var cwd = process.cwd();
            var relativePath = file.path.substr(cwd.length);
            var folderName = this.workingFolder + path.dirname(relativePath);
            mkdirp.sync(folderName);
            var targetFile = path.join(folderName, path.basename(relativePath));
            this.fileMap[file.path] = targetFile;
            var instrumentingStream = this.coverageInstrumenter ?
                this.coverageInstrumenter.instrumenterStreamForFile(file) : null;
            return TempFolder_1.TempFolder.instance().copyFile(file.path, targetFile, instrumentingStream);
        }
    };
    Sandbox.prototype.initializeTestRunner = function () {
        var _this = this;
        var files = this.files.map(function (originalFile) { return _.assign(_.cloneDeep(originalFile), { path: _this.fileMap[originalFile.path] }); });
        files.unshift({ path: this.testHooksFile, mutated: false, included: true });
        var settings = {
            files: files,
            strykerOptions: this.options,
            port: this.options.port + this.index,
            sandboxWorkingFolder: this.workingFolder
        };
        log.debug("Creating test runner %s using settings {port: %s}", this.index, settings.port);
        this.testRunner = ResilientTestRunnerFactory_1.default.create(settings.strykerOptions.testRunner || '', settings);
        return this.testRunner.init();
    };
    Sandbox.prototype.calculateTimeout = function (mutant) {
        var baseTimeout = mutant.timeSpentScopedTests;
        return (this.options.timeoutFactor * baseTimeout) + this.options.timeoutMs;
    };
    Sandbox.prototype.filterTests = function (mutant) {
        if (this.testFramework) {
            var fileContent = objectUtils_1.wrapInClosure(this.testFramework.filter(mutant.scopedTestIds));
            return TempFolder_1.TempFolder.instance().writeFile(this.testHooksFile, fileContent);
        }
        else {
            return Promise.resolve(void 0);
        }
    };
    return Sandbox;
}());
exports.default = Sandbox;
//# sourceMappingURL=Sandbox.js.map