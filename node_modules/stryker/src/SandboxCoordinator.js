"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var log4js = require("log4js");
var os = require("os");
var _ = require("lodash");
var test_runner_1 = require("stryker-api/test_runner");
var report_1 = require("stryker-api/report");
var objectUtils_1 = require("./utils/objectUtils");
var Sandbox_1 = require("./Sandbox");
var PromisePool = require('es6-promise-pool');
var log = log4js.getLogger('SandboxCoordinator');
// The initial run might take a while.
// For example: angular-bootstrap takes up to 45 seconds.
// Lets take 5 minutes just to be sure
var INITIAL_RUN_TIMEOUT = 60 * 1000 * 5;
var SandboxCoordinator = /** @class */ (function () {
    function SandboxCoordinator(options, files, testFramework, reporter) {
        this.options = options;
        this.files = files;
        this.testFramework = testFramework;
        this.reporter = reporter;
    }
    SandboxCoordinator.prototype.initialRun = function (coverageInstrumenter) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                if (this.files.length > 0) {
                    log.info("Starting initial test run. This may take a while.");
                    return [2 /*return*/, this.startTestRun(coverageInstrumenter)];
                }
                else {
                    log.info("No files have been found. Aborting initial test run.");
                    return [2 /*return*/, this.createDryRunResult()];
                }
                return [2 /*return*/];
            });
        });
    };
    SandboxCoordinator.prototype.runMutants = function (mutants) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var results, sandboxes, promiseProducer;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mutants = _.clone(mutants); // work with a copy because we're changing state (pop'ing values)
                        results = [];
                        return [4 /*yield*/, this.createSandboxes()];
                    case 1:
                        sandboxes = _a.sent();
                        promiseProducer = function () {
                            var mutant = mutants.shift();
                            if (!mutant) {
                                return null; // we're done
                            }
                            else {
                                if (mutant.scopedTestIds.length > 0) {
                                    var sandbox_1 = sandboxes.shift();
                                    if (sandbox_1) {
                                        return sandbox_1.runMutant(mutant)
                                            .then(function (runResult) {
                                            _this.reportMutantTested(mutant, runResult, results);
                                            sandboxes.push(sandbox_1); // mark the sandbox as available again
                                        });
                                    }
                                    else {
                                        return null;
                                    }
                                }
                                else {
                                    _this.reportMutantTested(mutant, null, results);
                                    return Promise.resolve();
                                }
                            }
                        };
                        return [4 /*yield*/, new PromisePool(promiseProducer, sandboxes.length).start()];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.reportAllMutantsTested(results)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, Promise.all(sandboxes.map(function (sandbox) { return sandbox.dispose(); }))];
                    case 4:
                        _a.sent();
                        return [2 /*return*/, results];
                }
            });
        });
    };
    SandboxCoordinator.prototype.createSandboxes = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var numConcurrentRunners, numConcurrentRunnersSource, sandboxes, i;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        numConcurrentRunners = os.cpus().length;
                        numConcurrentRunnersSource = 'CPU count';
                        if (numConcurrentRunners > this.options.maxConcurrentTestRunners && this.options.maxConcurrentTestRunners > 0) {
                            numConcurrentRunners = this.options.maxConcurrentTestRunners;
                            numConcurrentRunnersSource = 'maxConcurrentTestRunners config';
                        }
                        sandboxes = [];
                        for (i = 0; i < numConcurrentRunners; i++) {
                            sandboxes.push(new Sandbox_1.default(this.options, i, this.files, this.testFramework, null));
                        }
                        log.info("Creating " + numConcurrentRunners + " test runners (based on " + numConcurrentRunnersSource + ")");
                        return [4 /*yield*/, Promise.all(sandboxes.map(function (s) { return s.initialize(); }))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, sandboxes];
                }
            });
        });
    };
    SandboxCoordinator.prototype.startTestRun = function (coverageInstrumenter) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var sandbox, runResult;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sandbox = new Sandbox_1.default(this.options, 0, this.files, this.testFramework, coverageInstrumenter);
                        return [4 /*yield*/, sandbox.initialize()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, sandbox.run(INITIAL_RUN_TIMEOUT)];
                    case 2:
                        runResult = _a.sent();
                        return [4 /*yield*/, sandbox.dispose()];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, runResult];
                }
            });
        });
    };
    SandboxCoordinator.prototype.createDryRunResult = function () {
        return {
            status: test_runner_1.RunStatus.Complete,
            tests: [],
            errorMessages: []
        };
    };
    SandboxCoordinator.prototype.reportMutantTested = function (mutant, runResult, results) {
        var result = this.collectFrozenMutantResult(mutant, runResult);
        results.push(result);
        this.reporter.onMutantTested(result);
    };
    SandboxCoordinator.prototype.collectFrozenMutantResult = function (mutant, runResult) {
        var status = report_1.MutantStatus.NoCoverage;
        var testNames;
        if (runResult) {
            switch (runResult.status) {
                case test_runner_1.RunStatus.Timeout:
                    status = report_1.MutantStatus.TimedOut;
                    break;
                case test_runner_1.RunStatus.Error:
                    status = report_1.MutantStatus.Error;
                    break;
                case test_runner_1.RunStatus.Complete:
                    if (runResult.tests.some(function (t) { return t.status === test_runner_1.TestStatus.Failed; })) {
                        status = report_1.MutantStatus.Killed;
                    }
                    else {
                        status = report_1.MutantStatus.Survived;
                    }
                    break;
            }
            testNames = runResult.tests
                .filter(function (t) { return t.status !== test_runner_1.TestStatus.Skipped; })
                .map(function (t) { return t.name; });
        }
        else {
            testNames = [];
        }
        var result = {
            sourceFilePath: mutant.filename,
            mutatorName: mutant.mutatorName,
            status: status,
            replacement: mutant.replacement,
            location: mutant.location,
            range: mutant.range,
            testsRan: testNames,
            originalLines: mutant.originalLines,
            mutatedLines: mutant.mutatedLines,
        };
        objectUtils_1.freezeRecursively(result);
        return result;
    };
    SandboxCoordinator.prototype.reportAllMutantsTested = function (results) {
        objectUtils_1.freezeRecursively(results);
        this.reporter.onAllMutantsTested(results);
    };
    return SandboxCoordinator;
}());
exports.default = SandboxCoordinator;
//# sourceMappingURL=SandboxCoordinator.js.map