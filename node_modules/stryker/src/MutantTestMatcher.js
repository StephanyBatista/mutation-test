"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log4js = require("log4js");
var _ = require("lodash");
var log = log4js.getLogger('MutantTestMatcher');
var MutantTestMatcher = /** @class */ (function () {
    function MutantTestMatcher(mutants, initialRunResult, statementMaps, options, reporter) {
        this.mutants = mutants;
        this.initialRunResult = initialRunResult;
        this.statementMaps = statementMaps;
        this.options = options;
        this.reporter = reporter;
    }
    Object.defineProperty(MutantTestMatcher.prototype, "baseline", {
        get: function () {
            if (this.isCoveragePerTestResult(this.initialRunResult.coverage)) {
                return this.initialRunResult.coverage.baseline;
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    MutantTestMatcher.prototype.matchWithMutants = function () {
        var _this = this;
        if (this.options.coverageAnalysis === 'off') {
            this.mutants.forEach(function (mutant) { return mutant.addAllTestResults(_this.initialRunResult); });
        }
        else if (!this.initialRunResult.coverage) {
            log.warn('No coverage result found, even though coverageAnalysis is "%s". Assuming that all tests cover each mutant. This might have a big impact on the performance.', this.options.coverageAnalysis);
            this.mutants.forEach(function (mutant) { return mutant.addAllTestResults(_this.initialRunResult); });
        }
        else
            this.mutants.forEach(function (mutant) {
                var statementMap = _this.statementMaps[mutant.filename];
                var smallestStatement = _this.findSmallestCoveringStatement(mutant, statementMap);
                if (smallestStatement) {
                    if (_this.isCoveredByBaseline(mutant.filename, smallestStatement)) {
                        mutant.addAllTestResults(_this.initialRunResult);
                    }
                    else {
                        _this.initialRunResult.tests.forEach(function (testResult, id) {
                            if (_this.isCoveredByTest(id, mutant.filename, smallestStatement)) {
                                mutant.addTestResult(id, testResult);
                            }
                        });
                    }
                }
                else {
                    log.warn('Cannot find statement for mutant %s in statement map for file. Assuming that all tests cover this mutant. This might have a big impact on the performance.', mutant.toString());
                    mutant.addAllTestResults(_this.initialRunResult);
                }
            });
        this.reporter.onAllMutantsMatchedWithTests(Object.freeze(this.mutants.map(this.mapMutantOnMatchedMutant)));
    };
    MutantTestMatcher.prototype.isCoveredByBaseline = function (filename, statementId) {
        if (this.baseline) {
            var coverageCollection = this.baseline[filename];
            return coverageCollection && coverageCollection.s[statementId] > 0;
        }
        else {
            return false;
        }
    };
    MutantTestMatcher.prototype.isCoveredByTest = function (testId, filename, statementId) {
        var coverageCollection = this.findCoverageCollectionForTest(testId);
        var coveredFile = coverageCollection && coverageCollection[filename];
        return coveredFile && coveredFile.s[statementId] > 0;
    };
    /**
     * Map the Mutant object on the MatchMutant Object.
     * @param mutant The mutant.
     * @returns The MatchedMutant
     */
    MutantTestMatcher.prototype.mapMutantOnMatchedMutant = function (mutant) {
        var matchedMutant = _.cloneDeep({
            mutatorName: mutant.mutatorName,
            scopedTestIds: mutant.scopedTestIds,
            timeSpentScopedTests: mutant.timeSpentScopedTests,
            filename: mutant.filename,
            replacement: mutant.replacement
        });
        return Object.freeze(matchedMutant);
    };
    /**
     * Finds the smallest statement that covers a mutant.
     * @param mutant The mutant.
     * @param statementMap of the covering file.
     * @returns The index of the coveredFile which contains the smallest statement surrounding the mutant.
     */
    MutantTestMatcher.prototype.findSmallestCoveringStatement = function (mutant, statementMap) {
        var _this = this;
        var smallestStatement = null;
        if (statementMap) {
            Object.keys(statementMap).forEach(function (statementId) {
                var location = statementMap[statementId];
                if (_this.statementCoversMutant(mutant.location, location) && (!smallestStatement || _this.isNewSmallestStatement(statementMap[smallestStatement], location))) {
                    smallestStatement = statementId;
                }
            });
        }
        return smallestStatement;
    };
    /**
     * Indicates whether a statement is the smallest statement of the two statements provided.
     * @param originalLocation The area which may cover a bigger area than the newLocation.
     * @param newLocation The area which may cover a smaller area than the originalLocation.
     * @returns true if the newLocation covers a smaller area than the originalLocation, making it the smaller statement.
     */
    MutantTestMatcher.prototype.isNewSmallestStatement = function (originalLocation, newLocation) {
        var statementIsSmallestStatement = false;
        if (!originalLocation) {
            statementIsSmallestStatement = true;
        }
        else {
            var lineDifference = (originalLocation.end.line - originalLocation.start.line) - (newLocation.end.line - newLocation.start.line);
            var coversLessLines = lineDifference > 0;
            var coversLessColumns = lineDifference === 0 && (newLocation.start.column - originalLocation.start.column) + (originalLocation.end.column - newLocation.end.column) > 0;
            if (coversLessLines || coversLessColumns) {
                statementIsSmallestStatement = true;
            }
        }
        return statementIsSmallestStatement;
    };
    /**
     * Indicates whether a statement covers a mutant.
     * @param mutantLocation The location of the mutant.
     * @param statementLocation The location of the statement.
     * @returns true if the statment covers the mutant.
     */
    MutantTestMatcher.prototype.statementCoversMutant = function (mutantLocation, statementLocation) {
        var mutantIsAfterStart = mutantLocation.start.line > statementLocation.start.line ||
            (mutantLocation.start.line === statementLocation.start.line && mutantLocation.start.column >= statementLocation.start.column);
        var mutantIsBeforeEnd = mutantLocation.end.line < statementLocation.end.line ||
            (mutantLocation.end.line === statementLocation.end.line && mutantLocation.end.column <= statementLocation.end.column);
        return mutantIsAfterStart && mutantIsBeforeEnd;
    };
    MutantTestMatcher.prototype.findCoverageCollectionForTest = function (testId) {
        if (this.initialRunResult.coverage) {
            if (this.isCoveragePerTestResult(this.initialRunResult.coverage)) {
                return this.initialRunResult.coverage.deviations[testId];
            }
            else {
                return this.initialRunResult.coverage;
            }
        }
        else {
            return null;
        }
    };
    MutantTestMatcher.prototype.isCoveragePerTestResult = function (coverage) {
        return this.options.coverageAnalysis === 'perTest';
    };
    return MutantTestMatcher;
}());
exports.default = MutantTestMatcher;
//# sourceMappingURL=MutantTestMatcher.js.map